---
description: このルールファイルは、Deno開発における包括的なガイドラインを提供し、コード構成、セキュリティ、パフォーマンス、テスト、ドキュメントのベストプラクティスをカバーしています。これらの標準に従うことで、保守性が高く、効率的で安全なDenoアプリケーションを確保できます。
globs: *.ts,*.tsx,*.js,*.jsx,*.md
---
- **TypeScriptを使用する**: 強い型付けによりコード品質と保守性を向上させるため、常にTypeScriptを優先してください。明確な型アノテーションを提供し、より良い構造のためにインターフェースを使用してください。
- **JSDocによるドキュメント化**: すべてのエクスポートされたシンボルのドキュメント化にJSDocを活用してください。簡潔な要約、型情報、例を含めてください。ドキュメントはコードの変更に合わせて最新の状態に保ってください。
- **一貫した命名規則**: 変数と関数にはcamelCase、クラスにはPascalCase、定数にはUPPER_SNAKE_CASEなど、確立された命名規則に従ってください。この一貫性は可読性と保守性を助けます。
- **関数パラメータの制限**: 関数は理想的には2つ以下のパラメータを取るべきで、追加のパラメータにはオプションオブジェクトを使用してください。これにより関数が使いやすく、テストしやすくなります。

## 1. コードの構成と構造

- **ディレクトリ構造のベストプラクティス**:
    - `src/`: アプリケーションのメインソースコードを含む
    - `src/components/`: 再利用可能なUIコンポーネント（該当する場合）
    - `src/services/`: ビジネスロジックとAPIとのやり取り
    - `src/utils/`: ユーティリティ関数とヘルパー
    - `tests/`: ユニットテストと統合テスト
    - `mod.ts`: モジュールまたはアプリケーションのメインエントリーポイント
    - `deps.ts`: 集中化された依存関係管理ファイル（詳細は後述）
    - `dev_deps.ts`: 集中化された開発依存関係管理ファイル（詳細は後述）
    - `deno.json`: Deno設定ファイル
- **ファイル命名規則**:
    - `.ts`、`.tsx`、`.js`、または`.jsx`拡張子で説明的な名前を使用
    - コンポーネントファイル: `ComponentName.tsx` または `component-name.tsx`
    - サービスファイル: `service-name.ts`
    - ユーティリティファイル: `utils.ts` または `string_utils.ts`
    - テストファイル: `file_name_test.ts`
- **モジュール構成のベストプラクティス**:
    - 明確な責任を持つ小さく焦点を絞ったモジュールを優先
    - 循環依存を避ける
    - 依存関係を一元管理するために`deps.ts`を使用。このファイルはプロジェクトで使用されるすべての外部依存関係をエクスポートし、簡単なバージョン管理と更新を可能にします。例:

    ```typescript
    // deps.ts
    export * as log from "https://deno.land/std@0.224.0/log/mod.ts";
    export { assertEquals } from "https://deno.land/std@0.224.0/assert/mod.ts";
    export { serve } from "https://deno.land/std@0.224.0/http/server.ts";
    ```
    
    - 開発依存関係を一元管理するために`dev_deps.ts`を使用。例:

    ```typescript
    // dev_deps.ts
    export {
      assert,
      assertEquals,
      assertExists,
      assertNotEquals,
      assertRejects,
      assertStringIncludes,
    } from "https://deno.land/std@0.224.0/assert/mod.ts";
    export {
      FakeTime,
    } from "https://deno.land/std@0.224.0/testing/time.ts";
    ```

    - 他のモジュールでは`deps.ts`ファイルを使用して依存関係をインポート:

    ```typescript
    // my_module.ts
    import { log, assertEquals } from "./deps.ts";

    log.info("Hello, Deno!");
    ```
    
- **コンポーネントアーキテクチャの推奨事項**:
    - UI開発にはコンポーネントベースのアーキテクチャに従う（該当する場合）
    - 各コンポーネントは自己完結型で再利用可能であるべき
    - 複雑なアプリケーションでは`nano-states`や`unstate`のような状態管理ライブラリの使用を検討
- **コード分割戦略**:
    - 動的インポート（`import()`）を使用してオンデマンドでモジュールをロード
    - ルートや機能に基づいてコードを分割
    - 効率的なロードのためにDenoの組み込みモジュールキャッシングを活用
    - デプロイメント用に最適化されたバンドルを作成するために`deno bundle`を使用するが、過度なバンドルに注意

## 2. 一般的なパターンとアンチパターン

- **デザインパターン**: 
    - **モジュールパターン**: アクセスを制御しグローバルスコープの汚染を防ぐためにモジュール内にコードをカプセル化
    - **ファクトリーパターン**: インスタンス化する正確なクラスを指定せずにオブジェクトを作成
    - **オブザーバーパターン**: オブジェクト間の一対多の依存関係を定義し、あるオブジェクトの状態が変化したときにすべての依存オブジェクトが通知され自動的に更新される
    - **依存性注入**: コンポーネントを疎結合にする。複雑なモッキングフレームワークに頼ることなくテストで簡単に依存関係を交換できるため、Denoのモジュールシステムで有用
- **一般的なタスクの推奨アプローチ**:
    - **HTTPサーバー**: HTTPサーバー作成にはDenoの組み込み`Deno.serve`を使用
    - **ファイルシステムアクセス**: ファイルシステム操作には`Deno.readTextFile`、`Deno.writeTextFile`などを使用
    - **環境変数**: `Deno.env.get()`を使用して環境変数にアクセス
    - **プロセス管理**: 外部コマンドの実行には`Deno.run`を使用
- **アンチパターンとコードの臭い**:
    - **グローバルスコープの汚染**: グローバルスコープでの変数宣言を避ける
    - **深くネストしたコールバック**: より良い可読性のためにasync/awaitを使用してコードをリファクタリング
    - **エラーの無視**: try/catchブロックまたは`Result`型を使用して潜在的なエラーを常に処理
    - **過度な設計**: コードをシンプルに保ち、不必要な複雑さを避ける
    - **`deps.ts`を使用しない**: 依存関係を一元化してバージョン管理しないと、メンテナンスが困難になる
- **状態管理のベストプラクティス**:
    - シンプルなアプリケーションでは、ローカルコンポーネントの状態を使用
    - 複雑なアプリケーションでは、軽量な状態管理ライブラリまたはRedux（互換性のあるDenoポート経由）のようなより堅牢なソリューションの使用を検討
    - アプリケーションの状態を一元化し、予測可能に管理
    - 状態を直接変更することを避け、不変の更新を使用
- **エラーハンドリングパターン**:
    - 同期的なエラーハンドリングにはtry/catchブロックを使用
    - Promiseのエラー処理には`.catch()`を使用
    - 特定のシナリオ用にカスタムエラータイプを作成
    - デバッグのために十分なコンテキストでエラーをログ出力
    - 成功または失敗のケースを明示的に処理するために`Result`型の使用を検討

## 3. パフォーマンスの考慮事項

- **最適化技術**:
    - **I/O操作の最小化**: 可能な場合はファイルの読み書きをバッチ処理
    - **効率的なデータ構造**: ユースケースに適したデータ構造を使用（例：`Map` vs `Object`）
    - **非同期操作**: ノンブロッキング操作のためにasync/awaitを活用
    - **WebAssembly**: パフォーマンスクリティカルなタスクにWebAssemblyモジュールを利用
    - **`Deno.bench`**: パフォーマンスのボトルネックを特定するためにDenoの組み込みベンチマークツールを使用。`deno bench`で実行。テストするファイルの隣にベンチマークを記述
- **メモリ管理の考慮事項**:
    - 特にストリームとリソースを扱う際のメモリリークに注意
    - リソースが適切にクローズされることを確実にするために`finally`ブロックを使用
    - 不必要なオブジェクトと変数の作成を避ける
    - メモリ使用パターンを特定するためにアプリケーションをプロファイリング
- **レンダリング最適化（該当する場合）**:
    - 効率的なUI更新のために仮想DOM技術を使用
    - 画像やその他のアセットを最適化
    - オフスクリーンコンテンツの遅延読み込みを実装
- **バンドルサイズの最適化**:
    - デプロイメント用に最適化されたバンドルを作成するために`deno bundle`を使用
    - ツリーシェイキングで未使用のコードを削除
    - JavaScriptとCSSファイルをミニファイ
    - gzipまたはBrotliでアセットを圧縮
- **遅延読み込み戦略**:
    - 動的インポート（`import()`）を使用してオンデマンドでモジュールをロード
    - 画像やその他のアセットの遅延読み込みを実装
    - ルートや機能に基づいてコードを分割

## 4. セキュリティのベストプラクティス

- **一般的な脆弱性と予防**:
    - **リモートコード実行**: `Deno.run`には極めて慎重に、入力を検証し、信頼できないコードを実行しない
    - **クロスサイトスクリプティング（XSS）**: XSS攻撃を防ぐためにユーザー入力をサニタイズ（該当する場合）
    - **SQLインジェクション**: SQLインジェクションを防ぐためにパラメータ化クエリまたはORMを使用（該当する場合）
    - **サービス拒否（DoS）**: DoS攻撃を防ぐためにレート制限やその他の対策を実装
    - **サプライチェーン攻撃**: `deps.ts`と`deno.lock`で依存関係を慎重にレビューし、固定
- **入力検証**:
    - インジェクション攻撃とデータ破損を防ぐためにすべてのユーザー入力を検証
    - 入力形式を強制するために正規表現または専用の検証ライブラリを使用
    - 潜在的に悪意のある文字を削除するために入力をサニタイズ
- **認証と認可**:
    - OAuth 2.0やJWTのような安全な認証メカニズムを使用
    - 認可のためにロールベースアクセス制御（RBAC）または属性ベースアクセス制御（ABAC）を実装
    - bcryptまたはArgon2を使用してパスワードを安全に保存
- **データ保護**:
    - 保存時と転送時の機密データを暗号化
    - すべての通信にHTTPSを使用
    - 不正アクセスからデータを保護するために適切なアクセス制御を実装
    - 定期的にデータをバックアップし、復旧手順をテスト
- **安全なAPI通信**:
    - すべてのAPI通信にHTTPSを使用
    - APIリクエストとレスポンスを検証
    - 乱用を防ぐためにレート制限を実装
    - 認証にAPIキーまたはJWTを使用

## 5. テストアプローチ

- **ユニットテスト**:
    - 個々のコンポーネントと関数のユニットテストを作成
    - Denoの組み込みテストフレームワーク（`Deno.test`）を使用
    - テスト対象のユニットを分離するために依存関係をモック
    - 高いテストカバレッジを目指す
- **統合テスト**:
    - 異なるモジュール間の相互作用を検証する統合テストを作成
    - APIエンドポイントとデータフローをテスト
    - 統合テストにはテストデータベースまたはモックAPIを使用
- **エンドツーエンドテスト**:
    - アプリケーション全体のフローを検証するエンドツーエンドテストを作成
    - PlaywrightやPuppeteerのようなテストフレームワークを使用
    - ユーザーインタラクションとUI要素をテスト（該当する場合）
- **テストの構成**:
    - すべてのテストを保存するために`tests/`ディレクトリを作成
    - モジュールや機能に基づいてテストをサブディレクトリに整理
    - 説明的なテスト名を使用
    - `deno test`を使用してテストを実行
- **モッキングとスタブ**:
    - Denoの組み込みモッキング機能または`sinon`のようなモッキングライブラリを使用
    - 外部依存関係とAPI呼び出しをモック
    - 複雑な関数を簡略化したバージョンで置き換えるためにスタブを使用

## 6. 一般的な落とし穴と問題点

- **よくある間違い**:
    - **不正な権限**: 必要な権限（例：`--allow-read`、`--allow-net`）をリクエストしない
    - **キャッチされない例外**: エラーを適切に処理しない
    - **グローバル変数の汚染**: グローバルスコープで誤って変数を宣言
    - **`await`の欠落**: 非同期操作を`await`し忘れる
    - **一貫性のない依存関係バージョン**: `deps.ts`を使用して依存関係バージョンを管理しない
- **エッジケース**:
    - **大きなファイルの処理**: メモリの問題を避けるために大きなファイルを効率的にストリーミング
    - **クロスプラットフォーム互換性**: 異なるオペレーティングシステムでアプリケーションをテスト
    - **タイムゾーンの差異**: タイムゾーン変換を慎重に処理
- **バージョン固有の問題**:
    - Denoリリースの破壊的変更に注意
    - 移行ガイダンスについてはDenoリリースノートを参照
- **互換性の懸念事項**:
    - 異なるブラウザとDenoバージョンとの互換性を確保（該当する場合）
    - DenoとNode.js APIの違いに注意
- **デバッグ戦略**:
    - Denoの組み込みデバッガー（`deno inspect`）を使用
    - 基本的なデバッグには`console.log`ステートメントを使用
    - 高度なデバッグ機能のためにDenoサポートのあるコードエディタを使用
    - ブラウザ開発者ツールを使用してネットワークリクエストとレスポンスを検査

## 7. ツールと環境

- **推奨開発ツール**:
    - Deno拡張機能付きの**VS Code**
    - Denoプラグイン付きの**IntelliJ IDEA**
    - **Deno CLI**
- **ビルド設定**:
    - インポートマップ、リンティングルール、フォーマットオプションなどのDeno設定を行うために`deno.json`を使用。例:

    ```json
    {
      "imports": {
        "*": "./src/",
        "std/": "https://deno.land/std@0.224.0/"
      },
      "lint": {
        "rules": {
          "no-explicit-any": true
        }
      },
      "fmt": {
        "lineWidth": 120,
        "indentWidth": 2
      },
      "compilerOptions": {
          "jsx": "react-jsx",
          "jsxImportSource": "react"
      }
    }
    ```
    
- **リンティングとフォーマット**:
    - コードスタイルと潜在的なエラーをチェックするために`deno lint`を使用。`deno.json`でリンティングルールを設定
    - 設定されたスタイルに従ってコードをフォーマットするために`deno fmt`を使用。`deno.json`でフォーマットオプションを設定
    - pre-commitフックまたはCI/CDパイプラインを使用してワークフローにリンティングとフォーマットを統合
- **デプロイメント**:
    - **Deno Deploy**: Denoアプリケーションの簡単なサーバーレスホスティング。開始するのに設定ファイルは不要
    - **Docker**: 一貫したデプロイメントのためにDenoアプリをコンテナ化
    - **クラウドプロバイダー**: 標準的なデプロイメント方法を使用してAWS、Google Cloud、またはAzureにデプロイ
- **CI/CD統合**:
    - GitHub Actions、GitLab CI、または他のCI/CDプラットフォームを使用してテスト、リンティング、フォーマット、デプロイメントを自動化
    - すべてのコミットまたはプルリクエストでテストを実行するようにCI/CDパイプラインを設定
    - 本番環境へのデプロイメントを自動化

## 追加のベストプラクティス

- **ファイル名にアンダースコアを使用**: `file-server.ts`の代わりに`file_server.ts`を使用
- **新機能のテストを作成**: 各モジュールは公開機能のテストを含むか、テストを伴うべき
- **TODOコメント**: TODOコメントには括弧内に課題番号または作成者のGitHubユーザー名を含める。例：`// TODO(ry): Add tests.`
- **明示的に**: より多くのコードになっても明示的に
- **包括的なコード**: 包括的なコードのガイドラインに従う
- **依存関係の最小化**: 循環インポートを作らない
- **JSDoc**: すべてのエクスポートされたシンボルに優れたJSDocカバレッジを提供
- **リンティング問題の解決**: 必要に応じて警告を抑制するために`// deno-lint-ignore <rule>`を使用するが、控えめに使用
- **テストモジュール**: 公開機能を持つすべてのモジュール`foo.ts`にはテストモジュール`foo_test.ts`があるべき
- **明示的なユニットテスト**: ユニットテストに明確な名前を付ける
- **トップレベル関数**: トップレベル関数には矢印構文ではなく`function`キーワードを使用
- **stdライブラリ**: 標準ライブラリで外部コードに依存しない
- **ブラウザ互換性**: 適切な場所でブラウザ互換性を文書化し維持
- **`#`を`private`より優先**: `private`キーワードよりも`#`（プライベートクラスフィールド）を優先
- **命名規則**: 変数、関数、クラス、型、定数にcamelCase、PascalCase、UPPER_SNAKE_CASEを一貫して使用

これらのベストプラクティスに従うことで、保守性が高く、効率的で安全なDenoアプリケーションを作成できます。